<?xml version="1.0"?>
<!DOCTYPE html><html><head><meta charset="utf-8"/></head><body><h2>Programmation objet concurrente</h2><p>
              crédits : 3<br/>   
              résumé : 
         
            Depuis la généralisation des architectures multi-cœurs, la programmation parallèle est devenue incontournable pour développer des applications exploitant pleinement les capacités de traitement offertes par les ordinateurs actuels. Elle est aussi un moyen de simplifier la structure du logiciel en l'organisant sous la forme de tâches distinctes qui interagissent entre elles afin de répondre aux requêtes de l'utilisateur (ou de l'environnement).
         
         
            Cette UE présente aux étudiants du M1 les principales difficultés de la programmation multi-thread et les techniques classiques permettant de développer un code 
            correct et performant
            . Tout d'abord, les instructions de base liées à la classe Thread en Java sont introduites avec les concepts sous-jacents de 
            verrou
             et de 
            variable de condition
            . L'effet de ces instructions sur l'état d'un thread est illustré sur des exemples simples s'appuyant sur des diagrammes de séquence. Les notions d'indépendance et d'
            atomicité
             permettent ensuite de spécifier précisément les problèmes classiques de 
            synchronisation
             en séparant le besoin d'exclusion mutuelle des contraintes d'attente particulières. L'approche recommandée pour débuter est celle de la conception et de la programmation de 
            moniteurs
             (à la Hoare), étudiée sur plusieurs exemples classiques.
         
         
            Les outils dédiés à la programmation parallèle en Java sont également présentés en cours et exploités en Travaux Pratiques : locks divers, pools de threads, collections synchronisées ou concurrentes, objets atomiques, etc. Les difficultés propres à la 
            programmation sans verrou
             sont illustrées par la construction de structures de données simples et de verrous performants.
         
         
            Enfin, un aperçu du modèle mémoire Java permet d'initier les étudiants à la notion de programme « 
            bien synchronisé »
             et aux risques d'exécutions 
            inconsistantes séquentiellement
             du fait des optimisations de codes réalisées lors de la compilation ou de l'exécution.
         
         
            Description en cours d'actualisation.
         
   <br/>   
              lieu : <br/>  
              intervenants : 
            </p><p><a href="../intervenants/MORIN&#xA0;Remi.html">MORIN Remi</a></p><p> Cette UE apparait dans le ou les parcour(s) suivant :</p><p><a href="../parcours/Fiabilit&#xE9; et s&#xE9;curit&#xE9; informatique (FSI).html">Fiabilité et sécurité informatique (FSI)</a></p><p><a href="../parcours/Ing&#xE9;nierie du logiciel et des donn&#xE9;es (ILD).html">Ingénierie du logiciel et des données (ILD)</a></p><p><a href="../parcours/Intelligence artificielle et apprentissage automatique (IAAA).html">Intelligence artificielle et apprentissage automatique (IAAA)</a></p><p><a href="../parcours/Informatique et math&#xE9;matiques discr&#xE8;tes (IMD).html">Informatique et mathématiques discrètes (IMD)</a></p><p><a href="../parcours/G&#xE9;om&#xE9;trie et informatique graphique (GIG).html">Géométrie et informatique graphique (GIG)</a></p></body></html>
